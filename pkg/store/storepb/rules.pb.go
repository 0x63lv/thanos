// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rules.proto

package storepb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	protobuf "google/protobuf"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type AlertState int32

const (
	AlertState_PENDING  AlertState = 0
	AlertState_FIRING   AlertState = 1
	AlertState_INACTIVE AlertState = 2
)

var AlertState_name = map[int32]string{
	0: "PENDING",
	1: "FIRING",
	2: "INACTIVE",
}

var AlertState_value = map[string]int32{
	"PENDING":  0,
	"FIRING":   1,
	"INACTIVE": 2,
}

func (x AlertState) String() string {
	return proto.EnumName(AlertState_name, int32(x))
}

func (AlertState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8e722d3e922f0937, []int{0}
}

/// RuleGroups is set of rule groups.
/// This and below APIs are meant to be used for unmarshaling and marshsaling rules from/to Prometheus API.
/// That's why json tag has to be customized and matching https://github.com/prometheus/prometheus/blob/c530b4b456cc5f9ec249f771dff187eb7715dc9b/web/api/v1/api.go#L955
/// NOTE: See rules_custom_test.go for compatibility tests.
///
/// For rule parsing from YAML configuration other struct is used: https://github.com/prometheus/prometheus/blob/20b1f596f6fb16107ef0c244d240b0ad6da36829/pkg/rulefmt/rulefmt.go#L105
type RuleGroups struct {
	Groups []*RuleGroup `protobuf:"bytes,1,rep,name=groups,proto3" json:"groups"`
}

func (m *RuleGroups) Reset()         { *m = RuleGroups{} }
func (m *RuleGroups) String() string { return proto.CompactTextString(m) }
func (*RuleGroups) ProtoMessage()    {}
func (*RuleGroups) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e722d3e922f0937, []int{0}
}
func (m *RuleGroups) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RuleGroups) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RuleGroups.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RuleGroups) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuleGroups.Merge(m, src)
}
func (m *RuleGroups) XXX_Size() int {
	return m.Size()
}
func (m *RuleGroups) XXX_DiscardUnknown() {
	xxx_messageInfo_RuleGroups.DiscardUnknown(m)
}

var xxx_messageInfo_RuleGroups proto.InternalMessageInfo

/// RuleGroup has info for rules which are part of a group.
type RuleGroup struct {
	Name                      string              `protobuf:"bytes,1,opt,name=name,proto3" json:"name"`
	File                      string              `protobuf:"bytes,2,opt,name=file,proto3" json:"file"`
	Rules                     []*Rule             `protobuf:"bytes,3,rep,name=rules,proto3" json:"rules"`
	Interval                  float64             `protobuf:"fixed64,4,opt,name=interval,proto3" json:"interval"`
	EvaluationDurationSeconds float64             `protobuf:"fixed64,5,opt,name=evaluation_duration_seconds,json=evaluationDurationSeconds,proto3" json:"evaluationTime"`
	LastEvaluation            *protobuf.Timestamp `protobuf:"bytes,6,opt,name=last_evaluation,json=lastEvaluation,proto3" json:"lastEvaluation"`
	// Thanos specific.
	DeprecatedPartialResponseStrategy PartialResponseStrategy `protobuf:"varint,7,opt,name=DeprecatedPartialResponseStrategy,proto3,enum=thanos.PartialResponseStrategy" json:"partial_response_strategy"`
	PartialResponseStrategy           PartialResponseStrategy `protobuf:"varint,8,opt,name=PartialResponseStrategy,proto3,enum=thanos.PartialResponseStrategy" json:"partialResponseStrategy"`
}

func (m *RuleGroup) Reset()         { *m = RuleGroup{} }
func (m *RuleGroup) String() string { return proto.CompactTextString(m) }
func (*RuleGroup) ProtoMessage()    {}
func (*RuleGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e722d3e922f0937, []int{1}
}
func (m *RuleGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RuleGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RuleGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RuleGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuleGroup.Merge(m, src)
}
func (m *RuleGroup) XXX_Size() int {
	return m.Size()
}
func (m *RuleGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_RuleGroup.DiscardUnknown(m)
}

var xxx_messageInfo_RuleGroup proto.InternalMessageInfo

type Rule struct {
	// Types that are valid to be assigned to Result:
	//	*Rule_Recording
	//	*Rule_Alert
	Result isRule_Result `protobuf_oneof:"result"`
}

func (m *Rule) Reset()         { *m = Rule{} }
func (m *Rule) String() string { return proto.CompactTextString(m) }
func (*Rule) ProtoMessage()    {}
func (*Rule) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e722d3e922f0937, []int{2}
}
func (m *Rule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Rule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Rule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rule.Merge(m, src)
}
func (m *Rule) XXX_Size() int {
	return m.Size()
}
func (m *Rule) XXX_DiscardUnknown() {
	xxx_messageInfo_Rule.DiscardUnknown(m)
}

var xxx_messageInfo_Rule proto.InternalMessageInfo

type isRule_Result interface {
	isRule_Result()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Rule_Recording struct {
	Recording *RecordingRule `protobuf:"bytes,1,opt,name=recording,proto3,oneof" json:"recording,omitempty"`
}
type Rule_Alert struct {
	Alert *Alert `protobuf:"bytes,2,opt,name=alert,proto3,oneof" json:"alert,omitempty"`
}

func (*Rule_Recording) isRule_Result() {}
func (*Rule_Alert) isRule_Result()     {}

func (m *Rule) GetResult() isRule_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *Rule) GetRecording() *RecordingRule {
	if x, ok := m.GetResult().(*Rule_Recording); ok {
		return x.Recording
	}
	return nil
}

func (m *Rule) GetAlert() *Alert {
	if x, ok := m.GetResult().(*Rule_Alert); ok {
		return x.Alert
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Rule) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Rule_Recording)(nil),
		(*Rule_Alert)(nil),
	}
}

type AlertInstance struct {
	State       AlertState          `protobuf:"varint,1,opt,name=state,proto3,enum=thanos.AlertState" json:"state"`
	Labels      []*Label            `protobuf:"bytes,2,rep,name=labels,proto3" json:"labels"`
	Annotations []*Label            `protobuf:"bytes,3,rep,name=annotations,proto3" json:"annotations"`
	ActiveAt    *protobuf.Timestamp `protobuf:"bytes,4,opt,name=active_at,json=activeAt,proto3" json:"activeAt,omitempty"`
	Value       string              `protobuf:"bytes,5,opt,name=value,proto3" json:"value"`
}

func (m *AlertInstance) Reset()         { *m = AlertInstance{} }
func (m *AlertInstance) String() string { return proto.CompactTextString(m) }
func (*AlertInstance) ProtoMessage()    {}
func (*AlertInstance) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e722d3e922f0937, []int{3}
}
func (m *AlertInstance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlertInstance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlertInstance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlertInstance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlertInstance.Merge(m, src)
}
func (m *AlertInstance) XXX_Size() int {
	return m.Size()
}
func (m *AlertInstance) XXX_DiscardUnknown() {
	xxx_messageInfo_AlertInstance.DiscardUnknown(m)
}

var xxx_messageInfo_AlertInstance proto.InternalMessageInfo

type Alert struct {
	State                     AlertState          `protobuf:"varint,1,opt,name=state,proto3,enum=thanos.AlertState" json:"state"`
	Name                      string              `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Query                     string              `protobuf:"bytes,3,opt,name=query,proto3" json:"query"`
	DurationSeconds           float64             `protobuf:"fixed64,4,opt,name=duration_seconds,json=durationSeconds,proto3" json:"duration"`
	Labels                    []*Label            `protobuf:"bytes,5,rep,name=labels,proto3" json:"labels"`
	Annotations               []*Label            `protobuf:"bytes,6,rep,name=annotations,proto3" json:"annotations"`
	Alerts                    []*AlertInstance    `protobuf:"bytes,7,rep,name=alerts,proto3" json:"alerts"`
	Health                    string              `protobuf:"bytes,8,opt,name=health,proto3" json:"health"`
	LastError                 string              `protobuf:"bytes,9,opt,name=last_error,json=lastError,proto3" json:"lastError,omitempty"`
	EvaluationDurationSeconds float64             `protobuf:"fixed64,10,opt,name=evaluation_duration_seconds,json=evaluationDurationSeconds,proto3" json:"evaluationTime"`
	LastEvaluation            *protobuf.Timestamp `protobuf:"bytes,11,opt,name=last_evaluation,json=lastEvaluation,proto3" json:"lastEvaluation"`
}

func (m *Alert) Reset()         { *m = Alert{} }
func (m *Alert) String() string { return proto.CompactTextString(m) }
func (*Alert) ProtoMessage()    {}
func (*Alert) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e722d3e922f0937, []int{4}
}
func (m *Alert) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Alert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Alert.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Alert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Alert.Merge(m, src)
}
func (m *Alert) XXX_Size() int {
	return m.Size()
}
func (m *Alert) XXX_DiscardUnknown() {
	xxx_messageInfo_Alert.DiscardUnknown(m)
}

var xxx_messageInfo_Alert proto.InternalMessageInfo

type RecordingRule struct {
	Name                      string              `protobuf:"bytes,1,opt,name=name,proto3" json:"name"`
	Query                     string              `protobuf:"bytes,2,opt,name=query,proto3" json:"query"`
	Labels                    []*Label            `protobuf:"bytes,3,rep,name=labels,proto3" json:"labels"`
	Health                    string              `protobuf:"bytes,4,opt,name=health,proto3" json:"health"`
	LastError                 string              `protobuf:"bytes,5,opt,name=last_error,json=lastError,proto3" json:"lastError,omitempty"`
	EvaluationDurationSeconds float64             `protobuf:"fixed64,6,opt,name=evaluation_duration_seconds,json=evaluationDurationSeconds,proto3" json:"evaluationTime"`
	LastEvaluation            *protobuf.Timestamp `protobuf:"bytes,7,opt,name=last_evaluation,json=lastEvaluation,proto3" json:"lastEvaluation"`
}

func (m *RecordingRule) Reset()         { *m = RecordingRule{} }
func (m *RecordingRule) String() string { return proto.CompactTextString(m) }
func (*RecordingRule) ProtoMessage()    {}
func (*RecordingRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e722d3e922f0937, []int{5}
}
func (m *RecordingRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordingRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordingRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecordingRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordingRule.Merge(m, src)
}
func (m *RecordingRule) XXX_Size() int {
	return m.Size()
}
func (m *RecordingRule) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordingRule.DiscardUnknown(m)
}

var xxx_messageInfo_RecordingRule proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("thanos.AlertState", AlertState_name, AlertState_value)
	proto.RegisterType((*RuleGroups)(nil), "thanos.RuleGroups")
	proto.RegisterType((*RuleGroup)(nil), "thanos.RuleGroup")
	proto.RegisterType((*Rule)(nil), "thanos.Rule")
	proto.RegisterType((*AlertInstance)(nil), "thanos.AlertInstance")
	proto.RegisterType((*Alert)(nil), "thanos.Alert")
	proto.RegisterType((*RecordingRule)(nil), "thanos.RecordingRule")
}

func init() { proto.RegisterFile("rules.proto", fileDescriptor_8e722d3e922f0937) }

var fileDescriptor_8e722d3e922f0937 = []byte{
	// 839 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0x4f, 0x6f, 0xe3, 0x44,
	0x14, 0x8f, 0x93, 0xd8, 0x89, 0x9f, 0xfb, 0x8f, 0x81, 0xa5, 0xde, 0x2e, 0xc4, 0x21, 0xd2, 0x4a,
	0x11, 0x82, 0x54, 0xa4, 0x5a, 0x10, 0x37, 0x9a, 0x6d, 0xd9, 0x8d, 0x84, 0xca, 0x6a, 0x5a, 0x81,
	0xc4, 0x25, 0x9a, 0x26, 0xb3, 0xa9, 0x25, 0xc7, 0x63, 0x66, 0xc6, 0x95, 0xfa, 0x15, 0x10, 0x07,
	0xbe, 0x07, 0x5f, 0x64, 0x8f, 0x7b, 0xe0, 0xc0, 0xc9, 0x82, 0xf6, 0x66, 0x89, 0xef, 0x80, 0x3c,
	0xe3, 0x3f, 0x69, 0xd9, 0xd2, 0xee, 0x2a, 0x97, 0xbc, 0x99, 0xf7, 0xfb, 0x3d, 0x3f, 0xfb, 0xbd,
	0xdf, 0x7b, 0x01, 0x87, 0xc7, 0x01, 0x15, 0x83, 0x88, 0x33, 0xc9, 0x90, 0x25, 0xcf, 0x48, 0xc8,
	0xc4, 0x8e, 0x23, 0x2f, 0xa2, 0xc2, 0xb9, 0xf3, 0xc1, 0x9c, 0xcd, 0x99, 0x3a, 0xee, 0x66, 0xa7,
	0xdc, 0xeb, 0xcd, 0x19, 0x9b, 0x07, 0x74, 0x57, 0xdd, 0x4e, 0xe3, 0x97, 0xbb, 0xd2, 0x5f, 0x50,
	0x21, 0xc9, 0x22, 0xd2, 0x84, 0xde, 0x53, 0x00, 0x1c, 0x07, 0xf4, 0x19, 0x67, 0x71, 0x24, 0xd0,
	0x13, 0xb0, 0xe6, 0xea, 0xe4, 0x1a, 0xdd, 0x46, 0xdf, 0x19, 0xbe, 0x37, 0xd0, 0xa9, 0x06, 0x25,
	0x67, 0x04, 0x69, 0xe2, 0xe5, 0x24, 0x9c, 0xdb, 0xde, 0x1f, 0x4d, 0xb0, 0x4b, 0x06, 0xfa, 0x08,
	0x9a, 0x21, 0x59, 0x50, 0xd7, 0xe8, 0x1a, 0x7d, 0x7b, 0xd4, 0x4e, 0x13, 0x4f, 0xdd, 0xb1, 0xfa,
	0xcd, 0xd0, 0x97, 0x7e, 0x40, 0xdd, 0x7a, 0x85, 0x66, 0x77, 0xac, 0x7e, 0xd1, 0xe7, 0x60, 0xaa,
	0x2f, 0x75, 0x1b, 0x2a, 0xff, 0xda, 0x72, 0xfe, 0x91, 0x9d, 0x26, 0x9e, 0x86, 0xb1, 0x36, 0xa8,
	0x0f, 0x6d, 0x3f, 0x94, 0x94, 0x9f, 0x93, 0xc0, 0x6d, 0x76, 0x8d, 0xbe, 0x31, 0x5a, 0x4b, 0x13,
	0xaf, 0xf4, 0xe1, 0xf2, 0x84, 0x30, 0x3c, 0xa2, 0xe7, 0x24, 0x88, 0x89, 0xf4, 0x59, 0x38, 0x99,
	0xc5, 0x5c, 0x1f, 0x04, 0x9d, 0xb2, 0x70, 0x26, 0x5c, 0x53, 0x05, 0xa3, 0x34, 0xf1, 0x36, 0x2a,
	0xda, 0x89, 0xbf, 0xa0, 0xf8, 0x61, 0x75, 0x3f, 0xc8, 0xa3, 0x8e, 0x75, 0x10, 0xfa, 0x11, 0x36,
	0x03, 0x22, 0xe4, 0xa4, 0x62, 0xb8, 0x56, 0xd7, 0xe8, 0x3b, 0xc3, 0x9d, 0x81, 0x2e, 0xfb, 0xa0,
	0x28, 0xfb, 0xe0, 0xa4, 0x28, 0xbb, 0xce, 0x91, 0x85, 0x1d, 0x96, 0x51, 0xf8, 0xc6, 0x1d, 0xfd,
	0x6a, 0xc0, 0x27, 0x07, 0x34, 0xe2, 0x74, 0x4a, 0x24, 0x9d, 0xbd, 0x20, 0x5c, 0xfa, 0x24, 0xc0,
	0x54, 0x44, 0x2c, 0x14, 0xf4, 0x58, 0x72, 0x22, 0xe9, 0xfc, 0xc2, 0x6d, 0x75, 0x8d, 0xfe, 0xc6,
	0xd0, 0x2b, 0x4a, 0x74, 0x0b, 0x6d, 0xf4, 0x71, 0x9a, 0x78, 0x0f, 0x23, 0x0d, 0x4e, 0x78, 0x8e,
	0x4e, 0x44, 0x0e, 0xe3, 0xbb, 0x13, 0xa1, 0x73, 0xd8, 0xbe, 0xed, 0x1d, 0xda, 0xf7, 0x7b, 0x87,
	0x47, 0x69, 0xe2, 0x6d, 0x47, 0x6f, 0x06, 0xf1, 0x6d, 0x0f, 0xef, 0x85, 0xd0, 0xcc, 0xfa, 0x8e,
	0x9e, 0x80, 0xcd, 0xe9, 0x94, 0xf1, 0x99, 0x1f, 0xce, 0x95, 0xaa, 0x9c, 0xe1, 0x83, 0x52, 0x18,
	0x05, 0x90, 0x31, 0x9f, 0xd7, 0x70, 0xc5, 0x44, 0x8f, 0xc1, 0x24, 0x01, 0xe5, 0x52, 0x49, 0xcd,
	0x19, 0xae, 0x17, 0x21, 0xfb, 0x99, 0xf3, 0x79, 0x0d, 0x6b, 0x74, 0xd4, 0x06, 0x8b, 0x53, 0x11,
	0x07, 0xb2, 0xf7, 0x7b, 0x1d, 0xd6, 0x15, 0x38, 0x0e, 0x85, 0x24, 0xe1, 0x94, 0xa2, 0x3d, 0x30,
	0x85, 0x24, 0x52, 0x6b, 0x79, 0x63, 0x88, 0xae, 0x3d, 0xe2, 0x38, 0x43, 0xb4, 0x28, 0x15, 0x09,
	0x6b, 0x83, 0xbe, 0x00, 0x2b, 0x20, 0xa7, 0x34, 0x10, 0x6e, 0x5d, 0x89, 0xb8, 0x4c, 0xfc, 0x5d,
	0xe6, 0xd5, 0x03, 0xa4, 0x09, 0x38, 0xb7, 0xe8, 0x1b, 0x70, 0x48, 0x18, 0x32, 0xa9, 0xda, 0x5f,
	0x88, 0xff, 0x46, 0xdc, 0x66, 0x9a, 0x78, 0xcb, 0x2c, 0xbc, 0x7c, 0x41, 0xdf, 0x83, 0x4d, 0xa6,
	0xd2, 0x3f, 0xa7, 0x13, 0x22, 0xd5, 0x28, 0xfc, 0xbf, 0x0a, 0x3f, 0x4c, 0x13, 0x0f, 0xe9, 0x80,
	0x7d, 0xf9, 0x19, 0x5b, 0xf8, 0x92, 0x2e, 0x22, 0x79, 0x81, 0xdb, 0x85, 0x0f, 0x79, 0x60, 0x66,
	0x82, 0xa4, 0x6a, 0x34, 0x6c, 0xfd, 0x99, 0xca, 0x81, 0xb5, 0xe9, 0xfd, 0xd3, 0x04, 0x53, 0xd5,
	0xe1, 0xdd, 0xaa, 0x54, 0x6c, 0x89, 0xfa, 0x1b, 0xb7, 0x84, 0x07, 0xe6, 0xcf, 0x31, 0xe5, 0x17,
	0x6e, 0xa3, 0xca, 0xae, 0x1c, 0x58, 0x1b, 0xf4, 0x15, 0x6c, 0xfd, 0x67, 0x88, 0x97, 0x36, 0x40,
	0x81, 0xe1, 0xcd, 0xd9, 0x8d, 0xa1, 0xad, 0xba, 0x63, 0xbe, 0x63, 0x77, 0xac, 0xb7, 0xef, 0xce,
	0xd7, 0x60, 0x29, 0xb1, 0x09, 0xb7, 0xa5, 0x82, 0x1f, 0x5c, 0x2b, 0x51, 0x21, 0x37, 0x9d, 0x5c,
	0x13, 0x71, 0x6e, 0x51, 0x0f, 0xac, 0x33, 0x4a, 0x02, 0x79, 0xa6, 0x66, 0xcd, 0xd6, 0x1c, 0xed,
	0xc1, 0xb9, 0x45, 0x5f, 0x02, 0xe8, 0x45, 0xc4, 0x39, 0xe3, 0xae, 0xad, 0x78, 0xdb, 0x69, 0xe2,
	0xbd, 0xaf, 0xf6, 0x4a, 0xe6, 0x5c, 0x6a, 0xb1, 0x5d, 0x3a, 0xef, 0x5a, 0x8a, 0xb0, 0xa2, 0xa5,
	0xe8, 0xac, 0x62, 0x29, 0xf6, 0x7e, 0x69, 0xc0, 0xfa, 0xb5, 0x69, 0xbf, 0xe3, 0x8f, 0xa6, 0x94,
	0x50, 0xfd, 0x16, 0x09, 0x55, 0x4a, 0x68, 0xdc, 0x57, 0x09, 0x55, 0x33, 0x9a, 0xf7, 0x6c, 0x86,
	0xb9, 0xaa, 0x66, 0x58, 0x2b, 0x6a, 0x46, 0x6b, 0x15, 0xcd, 0xf8, 0x74, 0x0f, 0xa0, 0x9a, 0x6e,
	0xe4, 0x40, 0xeb, 0xc5, 0xe1, 0xd1, 0xc1, 0xf8, 0xe8, 0xd9, 0x56, 0x0d, 0x01, 0x58, 0xdf, 0x8e,
	0x71, 0x76, 0x36, 0xd0, 0x1a, 0xb4, 0xc7, 0x47, 0xfb, 0x4f, 0x4f, 0xc6, 0x3f, 0x1c, 0x6e, 0xd5,
	0x47, 0x8f, 0x5f, 0xfd, 0xdd, 0xa9, 0xbd, 0xba, 0xec, 0x18, 0xaf, 0x2f, 0x3b, 0xc6, 0x5f, 0x97,
	0x1d, 0xe3, 0xb7, 0xab, 0x4e, 0xed, 0xf5, 0x55, 0xa7, 0xf6, 0xe7, 0x55, 0xa7, 0xf6, 0x53, 0x4b,
	0x48, 0xc6, 0x69, 0x74, 0x7a, 0x6a, 0xa9, 0x77, 0xda, 0xfb, 0x37, 0x00, 0x00, 0xff, 0xff, 0x2c,
	0xa9, 0xea, 0x4d, 0xf4, 0x08, 0x00, 0x00,
}

func (m *RuleGroups) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleGroups) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RuleGroups) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for iNdEx := len(m.Groups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Groups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRules(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RuleGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RuleGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PartialResponseStrategy != 0 {
		i = encodeVarintRules(dAtA, i, uint64(m.PartialResponseStrategy))
		i--
		dAtA[i] = 0x40
	}
	if m.DeprecatedPartialResponseStrategy != 0 {
		i = encodeVarintRules(dAtA, i, uint64(m.DeprecatedPartialResponseStrategy))
		i--
		dAtA[i] = 0x38
	}
	if m.LastEvaluation != nil {
		{
			size, err := m.LastEvaluation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRules(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.EvaluationDurationSeconds != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.EvaluationDurationSeconds))))
		i--
		dAtA[i] = 0x29
	}
	if m.Interval != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Interval))))
		i--
		dAtA[i] = 0x21
	}
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRules(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.File) > 0 {
		i -= len(m.File)
		copy(dAtA[i:], m.File)
		i = encodeVarintRules(dAtA, i, uint64(len(m.File)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRules(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Rule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		{
			size := m.Result.Size()
			i -= size
			if _, err := m.Result.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Rule_Recording) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rule_Recording) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Recording != nil {
		{
			size, err := m.Recording.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRules(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Rule_Alert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rule_Alert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Alert != nil {
		{
			size, err := m.Alert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRules(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AlertInstance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertInstance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlertInstance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintRules(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ActiveAt != nil {
		{
			size, err := m.ActiveAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRules(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Annotations) > 0 {
		for iNdEx := len(m.Annotations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Annotations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRules(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Labels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRules(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.State != 0 {
		i = encodeVarintRules(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Alert) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Alert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastEvaluation != nil {
		{
			size, err := m.LastEvaluation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRules(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.EvaluationDurationSeconds != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.EvaluationDurationSeconds))))
		i--
		dAtA[i] = 0x51
	}
	if len(m.LastError) > 0 {
		i -= len(m.LastError)
		copy(dAtA[i:], m.LastError)
		i = encodeVarintRules(dAtA, i, uint64(len(m.LastError)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Health) > 0 {
		i -= len(m.Health)
		copy(dAtA[i:], m.Health)
		i = encodeVarintRules(dAtA, i, uint64(len(m.Health)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Alerts) > 0 {
		for iNdEx := len(m.Alerts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Alerts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRules(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Annotations) > 0 {
		for iNdEx := len(m.Annotations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Annotations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRules(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Labels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRules(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.DurationSeconds != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DurationSeconds))))
		i--
		dAtA[i] = 0x21
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintRules(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRules(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.State != 0 {
		i = encodeVarintRules(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecordingRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordingRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecordingRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastEvaluation != nil {
		{
			size, err := m.LastEvaluation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRules(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.EvaluationDurationSeconds != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.EvaluationDurationSeconds))))
		i--
		dAtA[i] = 0x31
	}
	if len(m.LastError) > 0 {
		i -= len(m.LastError)
		copy(dAtA[i:], m.LastError)
		i = encodeVarintRules(dAtA, i, uint64(len(m.LastError)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Health) > 0 {
		i -= len(m.Health)
		copy(dAtA[i:], m.Health)
		i = encodeVarintRules(dAtA, i, uint64(len(m.Health)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Labels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRules(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintRules(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRules(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintRules(dAtA []byte, offset int, v uint64) int {
	offset -= sovRules(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RuleGroups) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovRules(uint64(l))
		}
	}
	return n
}

func (m *RuleGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRules(uint64(l))
	}
	l = len(m.File)
	if l > 0 {
		n += 1 + l + sovRules(uint64(l))
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovRules(uint64(l))
		}
	}
	if m.Interval != 0 {
		n += 9
	}
	if m.EvaluationDurationSeconds != 0 {
		n += 9
	}
	if m.LastEvaluation != nil {
		l = m.LastEvaluation.Size()
		n += 1 + l + sovRules(uint64(l))
	}
	if m.DeprecatedPartialResponseStrategy != 0 {
		n += 1 + sovRules(uint64(m.DeprecatedPartialResponseStrategy))
	}
	if m.PartialResponseStrategy != 0 {
		n += 1 + sovRules(uint64(m.PartialResponseStrategy))
	}
	return n
}

func (m *Rule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		n += m.Result.Size()
	}
	return n
}

func (m *Rule_Recording) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Recording != nil {
		l = m.Recording.Size()
		n += 1 + l + sovRules(uint64(l))
	}
	return n
}
func (m *Rule_Alert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Alert != nil {
		l = m.Alert.Size()
		n += 1 + l + sovRules(uint64(l))
	}
	return n
}
func (m *AlertInstance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovRules(uint64(m.State))
	}
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovRules(uint64(l))
		}
	}
	if len(m.Annotations) > 0 {
		for _, e := range m.Annotations {
			l = e.Size()
			n += 1 + l + sovRules(uint64(l))
		}
	}
	if m.ActiveAt != nil {
		l = m.ActiveAt.Size()
		n += 1 + l + sovRules(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovRules(uint64(l))
	}
	return n
}

func (m *Alert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovRules(uint64(m.State))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRules(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovRules(uint64(l))
	}
	if m.DurationSeconds != 0 {
		n += 9
	}
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovRules(uint64(l))
		}
	}
	if len(m.Annotations) > 0 {
		for _, e := range m.Annotations {
			l = e.Size()
			n += 1 + l + sovRules(uint64(l))
		}
	}
	if len(m.Alerts) > 0 {
		for _, e := range m.Alerts {
			l = e.Size()
			n += 1 + l + sovRules(uint64(l))
		}
	}
	l = len(m.Health)
	if l > 0 {
		n += 1 + l + sovRules(uint64(l))
	}
	l = len(m.LastError)
	if l > 0 {
		n += 1 + l + sovRules(uint64(l))
	}
	if m.EvaluationDurationSeconds != 0 {
		n += 9
	}
	if m.LastEvaluation != nil {
		l = m.LastEvaluation.Size()
		n += 1 + l + sovRules(uint64(l))
	}
	return n
}

func (m *RecordingRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRules(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovRules(uint64(l))
	}
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovRules(uint64(l))
		}
	}
	l = len(m.Health)
	if l > 0 {
		n += 1 + l + sovRules(uint64(l))
	}
	l = len(m.LastError)
	if l > 0 {
		n += 1 + l + sovRules(uint64(l))
	}
	if m.EvaluationDurationSeconds != 0 {
		n += 9
	}
	if m.LastEvaluation != nil {
		l = m.LastEvaluation.Size()
		n += 1 + l + sovRules(uint64(l))
	}
	return n
}

func sovRules(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRules(x uint64) (n int) {
	return sovRules(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RuleGroups) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRules
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuleGroups: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuleGroups: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRules
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRules
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &RuleGroup{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRules(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRules
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRules
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuleGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRules
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuleGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuleGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRules
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRules
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRules
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRules
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRules
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRules
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &Rule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Interval = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvaluationDurationSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.EvaluationDurationSeconds = float64(math.Float64frombits(v))
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastEvaluation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRules
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRules
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastEvaluation == nil {
				m.LastEvaluation = &protobuf.Timestamp{}
			}
			if err := m.LastEvaluation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedPartialResponseStrategy", wireType)
			}
			m.DeprecatedPartialResponseStrategy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeprecatedPartialResponseStrategy |= PartialResponseStrategy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialResponseStrategy", wireType)
			}
			m.PartialResponseStrategy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartialResponseStrategy |= PartialResponseStrategy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRules(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRules
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRules
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRules
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recording", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRules
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRules
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RecordingRule{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &Rule_Recording{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRules
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRules
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Alert{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &Rule_Alert{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRules(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRules
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRules
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertInstance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRules
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertInstance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertInstance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= AlertState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRules
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRules
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, &Label{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRules
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRules
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Annotations = append(m.Annotations, &Label{})
			if err := m.Annotations[len(m.Annotations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRules
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRules
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActiveAt == nil {
				m.ActiveAt = &protobuf.Timestamp{}
			}
			if err := m.ActiveAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRules
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRules
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRules(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRules
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRules
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Alert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRules
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Alert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Alert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= AlertState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRules
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRules
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRules
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRules
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DurationSeconds = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRules
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRules
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, &Label{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRules
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRules
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Annotations = append(m.Annotations, &Label{})
			if err := m.Annotations[len(m.Annotations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alerts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRules
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRules
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alerts = append(m.Alerts, &AlertInstance{})
			if err := m.Alerts[len(m.Alerts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Health", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRules
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRules
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Health = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRules
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRules
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvaluationDurationSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.EvaluationDurationSeconds = float64(math.Float64frombits(v))
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastEvaluation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRules
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRules
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastEvaluation == nil {
				m.LastEvaluation = &protobuf.Timestamp{}
			}
			if err := m.LastEvaluation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRules(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRules
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRules
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordingRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRules
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordingRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordingRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRules
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRules
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRules
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRules
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRules
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRules
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, &Label{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Health", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRules
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRules
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Health = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRules
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRules
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvaluationDurationSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.EvaluationDurationSeconds = float64(math.Float64frombits(v))
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastEvaluation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRules
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRules
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRules
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastEvaluation == nil {
				m.LastEvaluation = &protobuf.Timestamp{}
			}
			if err := m.LastEvaluation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRules(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRules
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRules
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRules(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRules
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRules
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRules
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRules
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRules
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRules
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRules        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRules          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRules = fmt.Errorf("proto: unexpected end of group")
)
